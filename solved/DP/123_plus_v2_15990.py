"""
문제
정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 3가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 단, 같은 수를 두 번 이상 연속해서 사용하면 안 된다.

1+2+1
1+3
3+1
정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 100,000보다 작거나 같다.

출력
각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.

예제 입력 1 
3
4
7
10
예제 출력 1 
3
9
27
출처
문제를 만든 사람: baekjoon
"""
## 1. 출력을 동시에 하지 않음. => dict 구현보다 list 구현이 더 빠름.
# 나머지로 출력하는 경우, 나머지로 저장한 다음, 더하고 나서 다시 나머지 연산을 적용하면 잘 됨.
# 예를 들어, (a+b) % 10 = 34. a = 5, b = 29 일때, (5 % 10 + 29 % 10) % 10을 하면 나머지가 잘 나옴.
import sys
input = sys.stdin.readline

def main():
    T = int(input().rstrip("\n"))
    cases = []

    for _ in range(T): 
        n = int(input().rstrip("\n")) # 1 <= n <= 100000
        cases.append(n)

    dp_max = max(cases)

    if dp_max > 3:
        dp = [0] * (dp_max+1) # 1로 끝나는 것, 2로 끝나는 것, 3으로 끝나는 것 개수.
    else:
        dp = [0] * 4

    dp[1] = [1,0,0]
    dp[2] = [0,1,0]
    dp[3] = [1,1,1]

    print(f"{1}: {dp[1]}")
    print(f"{2}: {dp[2]}")
    print(f"{3}: {dp[3]}")

    if dp_max > 3:
        for i in range(4, dp_max+1):
            # dp[i] = {
            #     3:dp[i-3].get(1, 0) + dp[i-3].get(2, 0),    # 3이 더해지는데, 뒤에 1과 2이여야만 함.
            #     2:dp[i-2].get(1, 0) + dp[i-2].get(3, 0),    # 2이 더해지는데, 뒤에 1과 3이여야만 함.
            #     1:dp[i-1].get(2, 0) + dp[i-1].get(3, 0),    # 1이 더해지는데, 뒤에 2와 3이여야만 함.
            #     }
            dp[i] = [(dp[i-1][1] + dp[i-1][2])%1000000009, (dp[i-2][0] + dp[i-2][2])%1000000009, (dp[i-3][0] + dp[i-3][1])%1000000009]
            
    
    for n in cases:        
        print(sum(dp[n]) % 1000000009)



if __name__ == "__main__":
    main()


## 2. 출력을 동시에 함. 대신 모든 케이스 메모리에 저장되어 있음.
# import sys
# input = sys.stdin.readline

# def main():
#     T = int(input().rstrip("\n"))

#     dp = [0] * 100001 # 1로 끝나는 것, 2로 끝나는 것, 3으로 끝나는 것 개수.
#     dp[1] = {1:1}
#     dp[2] = {2:1}
#     dp[3] = {1:1, 2:1, 3:1}

#     for i in range(4, 100001):
#         dp[i] = {
#             3:dp[i-3].get(1, 0) + dp[i-3].get(2, 0),    # 3이 더해지는데, 뒤에 1과 2이여야만 함.
#             2:dp[i-2].get(1, 0) + dp[i-2].get(3, 0),    # 2이 더해지는데, 뒤에 1과 3이여야만 함.
#             1:dp[i-1].get(2, 0) + dp[i-1].get(3, 0),    # 1이 더해지는데, 뒤에 2와 3이여야만 함.
#             }
        
#     for _ in range(T): 
#         n = int(input().rstrip("\n")) # 1 <= n <= 100000
#         print(sum(dp[n].values()) % 1000000009)    


# if __name__ == "__main__":
#     main()